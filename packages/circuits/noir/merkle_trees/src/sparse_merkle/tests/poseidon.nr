use dep::std::hash::poseidon::bn254::{hash_2, hash_3};
use crate::sparse_merkle::SparseMerkleTree;

global TREE_DEPTH = 256;

fn poseidon_hasher(leaves: [Field]) -> Field {
    if leaves.len() == 2 {
        hash_2([leaves[0], leaves[1]])
    } else {
        hash_3([leaves[0], leaves[1], leaves[2]])
    }
}

#[test]
fn test_verify_membership_proof() {
    let root = 3532809757480436997969526334543526996242857122876262144596246439822675654128;
    let smt = SparseMerkleTree::from(root, poseidon_hasher);

    let key = 18746990989203767017840856832962652635369613415011636432610873672704085238844;
    let value = 10223238458026721676606706894638558676629446348345239719814856822628482567791;
    let entry = (key, value);
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[254] = 18126944477260144816572365299295230808286197301459941187567621915186392922196;
    siblings[255] = 7842913321420301106140788486336995496832503825951977327575501561489697540557;

    smt.membership(entry, siblings.as_slice());
}

#[test]
fn test_verify_non_membership_proof() {
    let root = 3532809757480436997969526334543526996242857122876262144596246439822675654128;
    let smt = SparseMerkleTree::from(root, poseidon_hasher);

    let key = 8459688297517826598613412977307486050019239051864711035321718508109192087854;
    let value = 8510347201346963732943571140849185725417245763047403804445415726302354045170;
    let entry = (key, value);
    let matching_entry = (
        13924553918840562069536446401916499801909138643922241340476956069386532478098, 13761779908325789083343687318102407319424329800042729673292939195255502025802
    );
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[254] = 14443001516360873457302534246953033880503978184674311810335857314606403404583;
    siblings[255] = 7842913321420301106140788486336995496832503825951977327575501561489697540557;

    smt.non_membership(entry, matching_entry, siblings.as_slice());
}

#[test]
fn test_add_first_element() {
    let mut smt = SparseMerkleTree::new(poseidon_hasher);

    let key = 20438969296305830531522370305156029982566273432331621236661483041446048135547;
    let value = 17150136040889237739751319962368206600863150289695545292530539263327413090784;
    let entry = (key, value);
    let siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];

    smt.add(entry, siblings.as_slice());
    assert(smt.root == 7842913321420301106140788486336995496832503825951977327575501561489697540557);
}

#[test]
fn test_add_element_to_one_element_tree() {
    let root = 7842913321420301106140788486336995496832503825951977327575501561489697540557;
    let mut smt = SparseMerkleTree::from(root, poseidon_hasher);

    let key = 8459688297517826598613412977307486050019239051864711035321718508109192087854;
    let value = 8510347201346963732943571140849185725417245763047403804445415726302354045170;
    let entry = (key, value);
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[255] = 7842913321420301106140788486336995496832503825951977327575501561489697540557;

    smt.add(entry, siblings.as_slice());
    assert(smt.root == 6309163561753770186763792861087421800063032915545949912480764922611421686766);
}

#[test]
fn test_add_element_to_existing_tree() {
    let root = 3532809757480436997969526334543526996242857122876262144596246439822675654128;
    let mut smt = SparseMerkleTree::from(root, poseidon_hasher);

    let key = 8459688297517826598613412977307486050019239051864711035321718508109192087854;
    let value = 8510347201346963732943571140849185725417245763047403804445415726302354045170;
    let entry = (key, value);
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[253] = 18126944477260144816572365299295230808286197301459941187567621915186392922196;
    siblings[254] = 14443001516360873457302534246953033880503978184674311810335857314606403404583;
    siblings[255] = 7842913321420301106140788486336995496832503825951977327575501561489697540557;
    let big_tree_root = 4657474665007910823901096287220097081233671466281873230928277896829046731272;

    smt.add(entry, siblings.as_slice());
    assert(smt.root == big_tree_root);
}

#[test]
fn test_delete() {
    let root = 4657474665007910823901096287220097081233671466281873230928277896829046731272;
    let mut smt = SparseMerkleTree::from(root, poseidon_hasher);

    let key = 8459688297517826598613412977307486050019239051864711035321718508109192087854;
    let value = 8510347201346963732943571140849185725417245763047403804445415726302354045170;
    let entry = (key, value);
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[253] = 18126944477260144816572365299295230808286197301459941187567621915186392922196;
    siblings[254] = 14443001516360873457302534246953033880503978184674311810335857314606403404583;
    siblings[255] = 7842913321420301106140788486336995496832503825951977327575501561489697540557;
    let small_tree_root = 3532809757480436997969526334543526996242857122876262144596246439822675654128;

    smt.delete(entry, siblings.as_slice());
    assert(smt.root == small_tree_root);
}

#[test]
fn test_update() {
    let root = 4202917944688591919039016743999516589372052081571553696755434379850460220435;
    let mut smt = SparseMerkleTree::from(root, poseidon_hasher);

    let key = 8459688297517826598613412977307486050019239051864711035321718508109192087854;
    let old_value = 8510347201346963732943571140849185725417245763047403804445415726302354045169;
    let new_value = 8510347201346963732943571140849185725417245763047403804445415726302354045170;
    let old_entry = (key, old_value);
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[253] = 18126944477260144816572365299295230808286197301459941187567621915186392922196;
    siblings[254] = 14443001516360873457302534246953033880503978184674311810335857314606403404583;
    siblings[255] = 7842913321420301106140788486336995496832503825951977327575501561489697540557;
    let big_tree_root = 4657474665007910823901096287220097081233671466281873230928277896829046731272;

    smt.update(new_value, old_entry, siblings.as_slice());
    assert(smt.root == big_tree_root);
}
